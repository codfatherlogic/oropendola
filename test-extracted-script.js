<script>
const vscode = acquireVsCodeApi();
const messagesContainer = document.getElementById("messagesContainer");
const messageInput = document.getElementById("messageInput");
const sendButton = document.getElementById("sendButton");
const stopButton = document.getElementById("stopButton");
const optimizeButton = document.getElementById("optimizeButton");
const emptyState = document.getElementById("emptyState");
const newChatBtn = document.getElementById("newChatBtn");
const settingsBtn = document.getElementById("settingsBtn");
const signOutBtn = document.getElementById("signOutBtn");
const modeSelector = document.getElementById("modeSelector");
const fileInput = document.getElementById("fileInput");
const attachmentsPreview = document.getElementById("attachmentsPreview");
const addContextBtn = document.getElementById("addContextBtn");
const attachImagesBtn = document.getElementById("attachImagesBtn");
const todoPanel = document.getElementById("todoPanel");
const todoHeader = document.getElementById("todoHeader");
const todoCollapseArrow = document.getElementById("todoCollapseArrow");
const todoContent = document.getElementById("todoContent");
const todoList = document.getElementById("todoList");
const todoStats = document.getElementById("todoStats");
const todoContext = document.getElementById("todoContext");
const todoContextText = document.getElementById("todoContextText");
const todoCreatedMessage = document.getElementById("todoCreatedMessage");
const todoCreatedText = document.getElementById("todoCreatedText");
const todoSyncBtn = document.getElementById("todoSyncBtn");
const todoClearBtn = document.getElementById("todoClearBtn");
let todoPanelCollapsed = true;
let attachedFiles = [];
let isGenerating = false;
let sendInProgress = false;
function safePostMessage(msg) { try { vscode.postMessage(msg); } catch(err) { console.error("[postMessage error]", err); } }
if (newChatBtn) newChatBtn.addEventListener("click", function() { try { safePostMessage({ type: "newChat" }); } catch(e) { console.error("[newChat error]", e); } });
if (settingsBtn) settingsBtn.addEventListener("click", function() { try { safePostMessage({ type: "openSettings" }); } catch(e) { console.error("[settings error]", e); } });
if (signOutBtn) signOutBtn.addEventListener("click", function() { try { safePostMessage({ type: "logout" }); } catch(e) { console.error("[logout error]", e); } });
if (sendButton) sendButton.addEventListener("click", function() { try { sendMessage(); } catch(e) { console.error("[send error]", e); resetInputState(); } });
if (stopButton) stopButton.addEventListener("click", function() { try { stopGeneration(); } catch(e) { console.error("[stop error]", e); resetInputState(); } });
if (optimizeButton) optimizeButton.addEventListener("click", function() { try { optimizeInput(); } catch(e) { console.error("[optimize error]", e); } });
if (modeSelector) modeSelector.addEventListener("change", function(e) { try { safePostMessage({ type: "switchMode", mode: e.target.value }); } catch(err) { console.error("[mode error]", err); } });
if (addContextBtn) addContextBtn.addEventListener("click", function() { try { safePostMessage({ type: "addContext" }); } catch(e) { console.error("[context error]", e); } });
if (attachImagesBtn) attachImagesBtn.addEventListener("click", function() { try { if (fileInput) fileInput.click(); } catch(e) { console.error("[attach error]", e); } });
if (todoSyncBtn) todoSyncBtn.addEventListener("click", function() { try { safePostMessage({ type: "syncTodos" }); } catch(e) { console.error("[todo sync error]", e); } });
if (todoClearBtn) todoClearBtn.addEventListener("click", function() { try { if (confirm("Clear all TODOs?")) { safePostMessage({ type: "clearTodos" }); } } catch(e) { console.error("[todo clear error]", e); } });
if (todoHeader) todoHeader.addEventListener("click", function(e) { if (e.target.closest(".todo-action-btn")) return; try { todoPanelCollapsed = !todoPanelCollapsed; if (todoPanelCollapsed) { todoPanel.classList.add("collapsed"); } else { todoPanel.classList.remove("collapsed"); } } catch(e) { console.error("[collapse error]", e); } });
if (fileInput) fileInput.addEventListener("change", function(e) { try { handleFileSelect(e); } catch(err) { console.error("[file error]", err); } });
document.querySelectorAll(".suggestion-btn").forEach(function(btn) { btn.addEventListener("click", function() { try { const text = btn.getAttribute("data-suggestion"); if (text) { messageInput.value = text; sendMessage(); } } catch(e) { console.error("[suggestion error]", e); } }); });
messageInput.addEventListener("keydown", function(e) { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
messageInput.addEventListener("input", function() { this.style.height = "auto"; this.style.height = Math.min(this.scrollHeight, 120) + "px"; });
messageInput.addEventListener("dragover", function(e) { e.preventDefault(); e.stopPropagation(); this.style.borderColor = "var(--vscode-focusBorder)"; });
messageInput.addEventListener("dragleave", function(e) { e.preventDefault(); e.stopPropagation(); this.style.borderColor = ""; });
messageInput.addEventListener("drop", function(e) { e.preventDefault(); e.stopPropagation(); this.style.borderColor = ""; const files = Array.from(e.dataTransfer.files); const imageFiles = files.filter(function(f) { return f.type.startsWith("image/"); }); imageFiles.forEach(function(file) { const reader = new FileReader(); reader.onload = function(event) { attachedFiles.push({ name: file.name, type: file.type, size: file.size, content: event.target.result, isImage: true }); updateAttachmentsPreview(); }; reader.readAsDataURL(file); }); });
messageInput.addEventListener("paste", function(e) { if (!e.clipboardData || !e.clipboardData.items) { return; } const items = e.clipboardData.items; let hasImage = false; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf("image") !== -1) { hasImage = true; e.preventDefault(); const blob = items[i].getAsFile(); if (!blob) { console.warn("[Could not get file from clipboard item]"); continue; } const reader = new FileReader(); reader.onload = function(event) { const timestamp = new Date().getTime(); attachedFiles.push({ name: "pasted-image-" + timestamp + ".png", type: blob.type, size: blob.size, content: event.target.result, isImage: true }); updateAttachmentsPreview(); console.log("[Image pasted successfully]:", blob.type, blob.size + " bytes"); }; reader.onerror = function(error) { console.error("[Failed to read pasted image]:", error); }; reader.readAsDataURL(blob); break; } } });
document.addEventListener("paste", function(e) { if (document.activeElement !== messageInput && e.clipboardData && e.clipboardData.items) { const items = e.clipboardData.items; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf("image") !== -1) { e.preventDefault(); const blob = items[i].getAsFile(); if (!blob) continue; const reader = new FileReader(); reader.onload = function(event) { const timestamp = new Date().getTime(); attachedFiles.push({ name: "pasted-image-" + timestamp + ".png", type: blob.type, size: blob.size, content: event.target.result, isImage: true }); updateAttachmentsPreview(); console.log("[Image pasted - global handler]:", blob.type, blob.size + " bytes"); }; reader.readAsDataURL(blob); break; } } } });
function sendMessage() { try { const text = messageInput.value.trim(); if (!text || sendInProgress) return; sendInProgress = true; if (emptyState) emptyState.style.display = "none"; isGenerating = true; sendButton.style.display = "none"; sendButton.disabled = true; stopButton.classList.add("visible"); messageInput.disabled = true; safePostMessage({ type: "sendMessage", text: text, attachments: attachedFiles }); messageInput.value = ""; attachedFiles = []; updateAttachmentsPreview(); messageInput.style.height = "auto"; setTimeout(function() { sendInProgress = false; }, 1000); } catch(e) { console.error("[sendMessage error]", e); resetInputState(); sendInProgress = false; } }
function stopGeneration() { try { isGenerating = false; sendInProgress = false; safePostMessage({ type: "stopGeneration" }); resetInputState(); } catch(e) { console.error("[stopGeneration error]", e); resetInputState(); } }
function resetInputState() { try { isGenerating = false; sendInProgress = false; sendButton.style.display = "block"; sendButton.disabled = false; stopButton.classList.remove("visible"); messageInput.disabled = false; optimizeButton.disabled = false; try { messageInput.focus(); } catch(e) { } } catch(e) { console.error("[resetInputState error]", e); } }
function optimizeInput() { try { const text = messageInput.value.trim(); if (!text) { console.warn("[No input to optimize]"); return; } optimizeButton.disabled = true; optimizeButton.innerHTML = "‚è≥"; const optimizationPrompt = "You are a smart prompt assistant. Understand user intent even with typos and short phrases. Fix spelling and grammar naturally. Expand short messages into clear requests. Preserve technical terms. Return ONLY the improved prompt in 1-3 sentences. Examples: fix bug becomes Fix the bug in this code. crete api becomes Create an API server. User input: " + text + " Improved:"; safePostMessage({ type: "optimizeInput", originalText: text, optimizationPrompt: optimizationPrompt }); } catch(e) { console.error("[optimizeInput error]", e); optimizeButton.disabled = false; optimizeButton.innerHTML = "&#10024;"; } }
function handleFileSelect(event) { const files = Array.from(event.target.files); files.forEach(function(file) { const reader = new FileReader(); reader.onload = function(e) { attachedFiles.push({ name: file.name, type: file.type, size: file.size, content: e.target.result, isImage: file.type.startsWith("image/") }); updateAttachmentsPreview(); }; if (file.type.startsWith("image/")) { reader.readAsDataURL(file); } else { reader.readAsText(file); } }); fileInput.value = ""; }
function removeAttachment(index) { attachedFiles.splice(index, 1); updateAttachmentsPreview(); }
function updateAttachmentsPreview() { if (attachedFiles.length === 0) { attachmentsPreview.style.display = "none"; attachmentsPreview.innerHTML = ""; return; } attachmentsPreview.style.display = "flex"; attachmentsPreview.innerHTML = attachedFiles.map(function(file, index) { if (file.isImage) { return "<div class=\'attachment-chip image-preview\'><img src=\'" + file.content + "\' class=\'attachment-image\' alt=\'" + file.name + "\' /><div style=\'display: flex; align-items: center; gap: 4px; width: 100%;\'><span class=\'attachment-name\' title=\'" + file.name + "\'> " + file.name + "</span><button class=\'attachment-remove\' data-index=\'" + index + "\' title=\'Remove\'>√ó</button></div></div>"; } else { return "<div class=\'attachment-chip\'><span>[File]</span><span class=\'attachment-name\' title=\'" + file.name + "\'>" + file.name + "</span><button class=\'attachment-remove\' data-index=\'" + index + "\' title=\'Remove\'>√ó</button></div>"; } }).join(""); attachmentsPreview.querySelectorAll(".attachment-remove").forEach(function(btn) { btn.addEventListener("click", function() { const index = parseInt(btn.getAttribute("data-index")); removeAttachment(index); }); }); }
window.addEventListener("message", function(event) { const message = event.data; switch (message.type) { case "addMessage": addMessageToUI(message.message); if (message.message.role === "assistant" || message.message.role === "error") { resetInputState(); } break; case "showTyping": showTypingIndicator(); break; case "hideTyping": hideTypingIndicator(); resetInputState(); break; case "clearChat": console.log("[WEBVIEW] Clearing chat"); if (messagesContainer) { messagesContainer.innerHTML = ""; } if (emptyState) { emptyState.style.display = "flex"; } hideTypingIndicator(); resetInputState(); console.log("[WEBVIEW] Chat cleared"); break; case "appendContext": if (messageInput && message.context) { const currentValue = messageInput.value; messageInput.value = currentValue + message.context; messageInput.style.height = "auto"; messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + "px"; messageInput.focus(); } break; case "updateInput": if (messageInput && message.text) { messageInput.value = message.text; messageInput.style.height = "auto"; messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + "px"; optimizeButton.disabled = false; optimizeButton.innerHTML = "&#10024;"; messageInput.focus(); } break; case "resetOptimizeButton": optimizeButton.disabled = false; optimizeButton.innerHTML = "&#10024;"; break; case "updateTodos": console.log("[WEBVIEW] updateTodos received", message.todos ? message.todos.length : 0, message.stats); renderTodos(message.todos, message.stats, message.context, message.relatedFiles); break; case "updateTodoStatus": if (message.todoId && message.status) { updateTodoStatus(message.todoId, message.status); } break; case "showToolExecution": console.log("[WEBVIEW] showToolExecution received", message.count); showTypingIndicator(); var thinkingText = document.querySelector(".thinking-state-text"); if (thinkingText) { thinkingText.textContent = message.message || ("Executing " + message.count + " action(s)"); } break; case "clearTodoList": if (todoList) { todoList.innerHTML = ""; } if (todoPanel) { todoPanel.classList.remove("visible"); } break; case "aiProgress": console.log("üî•üî•üî• [WEBVIEW] ========== RECEIVED AIPROGRESS MESSAGE =========="); console.log("[WEBVIEW] Message type:", message.data.type); console.log("[WEBVIEW] Message data:", JSON.stringify(message.data, null, 2)); handleAIProgress(message.data); console.log("üî• [WEBVIEW] handleAIProgress called"); break; } });
let typingElement = null;
let currentProgressBar = null;
let progressContainer = null;
let thinkingStateInterval = null;
let currentThinkingState = 0;
const thinkingStates = ["Thinking", "Forming", "Finding", "Actioning", "Pondering"];
function showTypingIndicator() { console.log("üí≠ [showTypingIndicator] Called"); if (emptyState) { console.log("üí≠ Hiding empty state"); emptyState.style.display = "none"; } hideTypingIndicator(); currentThinkingState = 0; typingElement = document.createElement("div"); typingElement.className = "claude-thinking-container"; typingElement.innerHTML = "<div class=\\"claude-thinking-header\\"><div class=\\"claude-thinking-text\\"><span class=\\"thinking-state-text\\">" + thinkingStates[0] + "</span><span class=\\"claude-thinking-dots\\"><span>.</span><span>.</span><span>.</span></span></div></div>"; console.log("üí≠ Appending thinking element to messages container"); console.log("üí≠ Messages container exists:", !!messagesContainer); messagesContainer.appendChild(typingElement); messagesContainer.scrollTop = messagesContainer.scrollHeight; console.log("üí≠ Thinking indicator shown, starting state rotation interval"); thinkingStateInterval = setInterval(function() { currentThinkingState = (currentThinkingState + 1) % thinkingStates.length; const stateTextEl = typingElement ? typingElement.querySelector(".thinking-state-text") : null; if (stateTextEl) { stateTextEl.style.opacity = "0"; setTimeout(function() { if (stateTextEl) { stateTextEl.textContent = thinkingStates[currentThinkingState]; stateTextEl.style.opacity = "1"; console.log("üí≠ Rotated to state:", thinkingStates[currentThinkingState]); } }, 150); } }, 2000); }
function hideTypingIndicator() { if (thinkingStateInterval) { clearInterval(thinkingStateInterval); thinkingStateInterval = null; } if (typingElement) { typingElement.remove(); typingElement = null; } currentThinkingState = 0; }
let currentStepElement = null;
function handleAIProgress(data) { try { console.log("üîî [AI Progress] Received event:", data.type); console.log("üîî [AI Progress] Full data:", JSON.stringify(data, null, 2)); switch (data.type) { case "showTyping": console.log("üí≠ Showing typing indicator"); if (data.show !== false) { showTypingIndicator(); if (data.message) { var thinkingText = document.querySelector(".thinking-state-text"); if (thinkingText) { thinkingText.textContent = data.message; } } } break; case "hideTyping": console.log("üí≠ Hiding typing indicator"); hideTypingIndicator(); break; case "understanding": console.log("üîç Understanding request"); showProgressMessage(data.message, data.status === "complete" ? "plan" : "thinking", data.status === "complete" ? "‚úì" : "üîç"); break; case "processing": console.log("‚öôÔ∏è Processing context"); showProgressMessage(data.message, "thinking", "‚öôÔ∏è"); break; case "thinking": console.log("üí≠ Showing thinking indicator"); showProgressMessage(data.message, "thinking", data.status === "complete" ? "‚úì" : "üß†"); break; case "plan": console.log("üìù Showing plan"); showProgressMessage(data.message, "plan", "üìù"); break; case "working": console.log("‚öôÔ∏è Updating progress bar"); updateProgressBar(data.step, data.total, data.message); break; case "executionStart": console.log("üöÄ Execution starting"); showProgressMessage(data.message || "üöÄ Starting execution...", "thinking", "üöÄ"); if (data.total_steps) { updateProgressBar(0, data.total_steps, "Starting..."); } break; case "toolExecutionStart": console.log("üîß Tool execution started"); console.log("üÜî Todo ID:", data.todo_id); console.log("üìä Step:", data.step, "/", data.total); if (data.todo_id) { console.log("‚úèÔ∏è Updating todo status to in_progress for:", data.todo_id); updateTodoStatus(data.todo_id, "in_progress"); } else { console.warn("‚ö†Ô∏è No todo_id provided in toolExecutionStart event!"); } hideTypingIndicator(); showProgressStep(data.message || "Working...", "in_progress"); if (data.step && data.total) { updateProgressBar(data.step - 1, data.total, data.message || "Working..."); } break; case "toolExecutionComplete": console.log("‚úÖ Tool execution completed"); console.log("üÜî Todo ID:", data.todo_id); console.log("‚úîÔ∏è Success:", data.success); if (data.todo_id && data.success !== false) { console.log("‚úèÔ∏è Updating todo status to completed for:", data.todo_id); updateTodoStatus(data.todo_id, "completed"); } else if (!data.todo_id) { console.warn("‚ö†Ô∏è No todo_id provided in toolExecutionComplete event!"); } completeProgressStep(data.message || "Done", data.success !== false); if (data.step && data.total) { updateProgressBar(data.step, data.total, data.success !== false ? "Completed" : "Failed"); } if (data.details_message) { showProgressMessage(data.details_message, "thinking", "   "); } break; case "executionComplete": console.log("‚úÖ All tools executed"); showProgressMessage(data.message || "‚úì Execution complete", "plan", "‚úÖ"); break; case "step_complete": console.log("üìã Step complete (legacy event)"); showStepComplete(data); break; case "complete": console.log("üéâ All complete"); clearProgressIndicators(); hideTypingIndicator(); break; case "error": console.error("‚ùå Error event:", data.message); showProgressMessage(data.message, "error", "‚ùå"); break; default: console.warn("‚ö†Ô∏è Unknown event type:", data.type); } } catch(e) { console.error("üí• [handleAIProgress error]", e); console.error("üí• Stack:", e.stack); } }
function showProgressStep(message, status) { try { if (emptyState) emptyState.style.display = "none"; if (!progressContainer) { progressContainer = document.createElement("div"); progressContainer.className = "progress-container"; messagesContainer.appendChild(progressContainer); } currentStepElement = document.createElement("div"); currentStepElement.className = "progress-step"; currentStepElement.innerHTML = "<span class=\\"progress-step-icon\\">‚è≥</span><span class=\\"progress-step-text\\">" + escapeHtml(message) + "</span>"; progressContainer.appendChild(currentStepElement); messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[showProgressStep error]", e); } }
function completeProgressStep(message, success) { try { if (currentStepElement) { const icon = success ? "‚úì" : "‚úó"; const className = success ? "success" : "error"; currentStepElement.className = "progress-step " + className; currentStepElement.innerHTML = "<span class=\\"progress-step-icon\\">" + icon + "</span><span class=\\"progress-step-text\\">" + escapeHtml(message) + "</span>"; currentStepElement = null; } } catch(e) { console.error("[completeProgressStep error]", e); } }
function showProgressMessage(message, className, icon) { try { if (emptyState) emptyState.style.display = "none"; const messageDiv = document.createElement("div"); messageDiv.className = "ai-progress-message " + className; const iconSpan = document.createElement("div"); iconSpan.className = "progress-icon"; iconSpan.textContent = icon; const textDiv = document.createElement("div"); textDiv.className = "progress-text"; if (className === "plan") { const lines = message.split("\\n"); textDiv.innerHTML = lines.map(function(line) { return escapeHtml(line); }).join("<br>"); } else { textDiv.textContent = message; } messageDiv.appendChild(iconSpan); messageDiv.appendChild(textDiv); if (!progressContainer) { progressContainer = document.createElement("div"); progressContainer.className = "progress-container"; messagesContainer.appendChild(progressContainer); } progressContainer.appendChild(messageDiv); if (className === "plan") { const separator = document.createElement("div"); separator.className = "ai-separator"; separator.textContent = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"; progressContainer.appendChild(separator); } messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[showProgressMessage error]", e); } }
function updateProgressBar(step, total, message) { try { if (!currentProgressBar) { const barContainer = document.createElement("div"); barContainer.className = "ai-progress-bar-container"; barContainer.innerHTML = "<div class=\\"ai-progress-bar\\"><div class=\\"ai-progress-fill\\"></div></div><div class=\\"ai-progress-text\\"></div>"; if (!progressContainer) { progressContainer = document.createElement("div"); progressContainer.className = "progress-container"; messagesContainer.appendChild(progressContainer); } progressContainer.appendChild(barContainer); currentProgressBar = barContainer; } const percentage = (step / total) * 100; const fill = currentProgressBar.querySelector(".ai-progress-fill"); const text = currentProgressBar.querySelector(".ai-progress-text"); if (fill) fill.style.width = percentage + "%"; if (text) text.textContent = message; if (step === total) { setTimeout(function() { if (currentProgressBar) { currentProgressBar.remove(); currentProgressBar = null; } }, 1000); } messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[updateProgressBar error]", e); } }
function showStepComplete(data) { try { const messageDiv = document.createElement("div"); messageDiv.className = "ai-progress-message step-complete" + (data.error ? " error" : ""); const icon = data.error ? "‚ùå" : "‚úÖ"; const iconSpan = document.createElement("div"); iconSpan.className = "progress-icon"; iconSpan.textContent = icon; const textDiv = document.createElement("div"); textDiv.className = "progress-text"; const stepMsg = document.createElement("div"); stepMsg.className = "step-message"; const lines = (data.message || "").split("\\n"); stepMsg.innerHTML = lines.map(function(line) { return escapeHtml(line); }).join("<br>"); textDiv.appendChild(stepMsg); if (data.details && data.details.length > 0) { const detailsList = document.createElement("ul"); detailsList.className = "step-details"; data.details.forEach(function(detail) { const li = document.createElement("li"); li.textContent = detail; detailsList.appendChild(li); }); textDiv.appendChild(detailsList); } if (data.file_path && data.line_count) { const badge = document.createElement("span"); badge.className = "file-change-badge"; badge.textContent = data.line_count + " lines"; textDiv.appendChild(badge); } messageDiv.appendChild(iconSpan); messageDiv.appendChild(textDiv); if (!progressContainer) { progressContainer = document.createElement("div"); progressContainer.className = "progress-container"; messagesContainer.appendChild(progressContainer); } progressContainer.appendChild(messageDiv); messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[showStepComplete error]", e); } }
function clearProgressIndicators() { try { if (currentProgressBar) { currentProgressBar.remove(); currentProgressBar = null; } if (progressContainer) { const separator = document.createElement("div"); separator.className = "ai-separator"; separator.textContent = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"; progressContainer.appendChild(separator); setTimeout(function() { if (progressContainer) { progressContainer.remove(); progressContainer = null; } }, 100); } } catch(e) { console.error("[clearProgressIndicators error]", e); } }
function addMessageToUI(message) { try { const role = (message && message.role) ? String(message.role).toLowerCase() : "assistant"; if (role === "system" || role === "error") { console.log("[addMessageToUI] Skipping system/error message:", message.content ? message.content.substring(0, 50) : ""); return; } if (role === "assistant" || role === "ai") { hideTypingIndicator(); } if (emptyState) emptyState.style.display = "none"; const messageDiv = document.createElement("div"); messageDiv.className = "message"; if (role === "user" || role === "human") { messageDiv.classList.add("message-user"); showTypingIndicator(); } else if (role === "assistant" || role === "ai") { messageDiv.classList.add("message-assistant"); } else { messageDiv.classList.add("message-assistant"); } const contentDiv = document.createElement("div"); contentDiv.className = "message-content"; contentDiv.innerHTML = formatMessageContent(message.content, message.file_changes); messageDiv.appendChild(contentDiv); if (role === "assistant") { const actionsDiv = document.createElement("div"); actionsDiv.className = "message-actions"; const copyBtn = document.createElement("button"); copyBtn.className = "message-action-btn"; copyBtn.textContent = "Copy"; copyBtn.onclick = function() { try { navigator.clipboard.writeText(message.content || ""); } catch(e) { console.warn("Copy failed", e); } copyBtn.textContent = "Copied!"; setTimeout(function() { copyBtn.textContent = "Copy"; }, 2000); }; actionsDiv.appendChild(copyBtn); messageDiv.appendChild(actionsDiv); } messagesContainer.appendChild(messageDiv); messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[addMessageToUI error]", e); } }
function formatMessageContent(content, fileChanges) { if (!content) return ""; let formatted = content; var lines = formatted.split("\\n"); var filteredLines = []; for (var i = 0; i < lines.length; i++) { var line = lines[i]; var trimmed = line.trim(); var isNumberedList = /^\\d+\\.\\s+/.test(trimmed); var isBulletPoint = /^[-*+]\\s+/.test(trimmed) && trimmed.length < 150; if (!isNumberedList && !isBulletPoint) { filteredLines.push(line); } } formatted = filteredLines.join("\\n"); formatted = formatted.replace(/```([\\w]*)[\\n]([\\s\\S]*?)```/g, function(match, lang, code) { const languageLabel = lang ? "<span class=\\"code-language\\">" + lang + "</span>" : ""; return "<div class=\\"code-block-container\\">" + languageLabel + "<pre><code class=\\"language-" + (lang || "plaintext") + "\\">" + escapeHtml(code.trim()) + "</code></pre></div>"; }); formatted = formatted.replace(/`([^`]+)`/g, "<code class=\\"inline-code\\">$1</code>"); formatted = formatted.replace(/\\*\\*([^*]+)\\*\\*/g, "<strong>$1</strong>"); formatted = formatted.replace(/\\*([^*]+)\\*/g, "<em>$1</em>"); formatted = formatted.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, "<a href=\\"$2\\" class=\\"message-link\\">$1</a>"); formatted = formatted.replace(/\\n/g, "<br>"); if (fileChanges) { const totalFiles = (fileChanges.created?.length || 0) + (fileChanges.modified?.length || 0) + (fileChanges.deleted?.length || 0); if (totalFiles > 0) { let changesHtml = "<div class=\\"file-changes-card\\"><div class=\\"file-changes-header\\" onclick=\\"this.parentElement.classList.toggle(\'collapsed\')\\"><div class=\\"file-changes-title\\"><span class=\\"file-changes-icon\\">üìÅ</span><span>Changed Files</span><span class=\\"file-changes-count\\">" + totalFiles + "</span></div><span class=\\"file-changes-arrow\\">‚ñº</span></div><div class=\\"file-changes-content\\">"; if (fileChanges.created && fileChanges.created.length > 0) { changesHtml += "<div class=\\"file-change-section\\"><div class=\\"file-change-section-title\\">‚ú® Created (" + fileChanges.created.length + ")</div><div class=\\"file-change-list\\">"; fileChanges.created.forEach(function(file) { const icon = getFileIcon(file); changesHtml += "<div class=\\"file-change-item created\\" onclick=\\"openFileLink(\'" + escapeHtml(file) + "\')\\" title=\\"Click to open\\"><span class=\\"file-icon\\">" + icon + "</span><span class=\\"file-change-path\\">" + escapeHtml(file) + "</span><span class=\\"file-change-badge created\\">NEW</span></div>"; }); changesHtml += "</div></div>"; } if (fileChanges.modified && fileChanges.modified.length > 0) { changesHtml += "<div class=\\"file-change-section\\"><div class=\\"file-change-section-title\\">‚úèÔ∏è Modified (" + fileChanges.modified.length + ")</div><div class=\\"file-change-list\\">"; fileChanges.modified.forEach(function(file) { const icon = getFileIcon(file); changesHtml += "<div class=\\"file-change-item modified\\" onclick=\\"openFileLink(\'" + escapeHtml(file) + "\')\\" title=\\"Click to open\\"><span class=\\"file-icon\\">" + icon + "</span><span class=\\"file-change-path\\">" + escapeHtml(file) + "</span><span class=\\"file-change-badge modified\\">MODIFIED</span></div>"; }); changesHtml += "</div></div>"; } if (fileChanges.deleted && fileChanges.deleted.length > 0) { changesHtml += "<div class=\\"file-change-section\\"><div class=\\"file-change-section-title\\">üóëÔ∏è Deleted (" + fileChanges.deleted.length + ")</div><div class=\\"file-change-list\\">"; fileChanges.deleted.forEach(function(file) { const icon = getFileIcon(file); changesHtml += "<div class=\\"file-change-item deleted\\"><span class=\\"file-icon\\">" + icon + "</span><span class=\\"file-change-path\\">" + escapeHtml(file) + "</span><span class=\\"file-change-badge deleted\\">DELETED</span></div>"; }); changesHtml += "</div></div>"; } changesHtml += "</div></div>"; formatted += changesHtml; } } return formatted; }
function displayFileChanges(fileChanges) { if (!fileChanges) return null; var created = fileChanges.created || []; var modified = fileChanges.modified || []; var deleted = fileChanges.deleted || []; var commands = fileChanges.commands || []; var allChanges = []; if (created.length > 0) { created.forEach(function(file, idx) { var filePath = typeof file === "string" ? file : file.path; var lineCount = file.line_count || 0; allChanges.push({ type: "created", path: filePath, lineCount: lineCount, details: file.details || [], index: idx }); }); } if (modified.length > 0) { modified.forEach(function(file, idx) { var filePath = typeof file === "string" ? file : file.path; var linesAdded = file.lines_added || 0; var linesRemoved = file.lines_removed || 0; allChanges.push({ type: "modified", path: filePath, linesAdded: linesAdded, linesRemoved: linesRemoved, details: file.details || [], index: idx }); }); } if (deleted.length > 0) { deleted.forEach(function(file, idx) { var filePath = typeof file === "string" ? file : file.path; allChanges.push({ type: "deleted", path: filePath, index: idx }); }); } if (allChanges.length === 0) return null; var cardId = "file-changes-" + Date.now(); var html = "<div class=\\"copilot-changes-container\\" id=\\"" + cardId + "\\">"; html += "<div class=\\"copilot-changes-header\\">"; html += "<span class=\\"copilot-changes-count\\">" + allChanges.length + " file" + (allChanges.length !== 1 ? "s" : "") + " changed</span>"; html += "</div>"; html += "<div class=\\"copilot-changes-list\\">"; allChanges.forEach(function(change, idx) { var changeId = cardId + "-change-" + idx; var icon = change.type === "created" ? "+" : (change.type === "modified" ? "~" : "-"); var iconClass = "copilot-change-icon " + change.type; html += "<div class=\\"copilot-change-item\\" id=\\"" + changeId + "\\">"; html += "<div class=\\"copilot-change-row\\">"; html += "<div class=\\"copilot-change-checkbox\\"><input type=\\"checkbox\\" class=\\"copilot-checkbox\\" id=\\"check-" + changeId + "\\" checked /></div>"; html += "<span class=\\"" + iconClass + "\\">" + icon + "</span>"; html += "<span class=\\"copilot-file-path\\" onclick=\\"openFileAndHighlight(" + String.fromCharCode(39) + change.path + String.fromCharCode(39) + ")\\" title=\\"Click to open\\">" + change.path + "</span>"; if (change.lineCount > 0) { html += "<span class=\\"copilot-line-count\\">" + change.lineCount + " lines</span>"; } else if (change.linesAdded > 0 || change.linesRemoved > 0) { html += "<span class=\\"copilot-diff-badge\\">"; if (change.linesAdded > 0) html += "<span class=\\"copilot-added\\">+" + change.linesAdded + "</span>"; if (change.linesRemoved > 0) html += "<span class=\\"copilot-removed\\">-" + change.linesRemoved + "</span>"; html += "</span>"; } html += "<div class=\\"copilot-change-actions\\">"; html += "<button class=\\"copilot-action-btn copilot-keep-btn\\" onclick=\\"keepFileChange(" + String.fromCharCode(39) + changeId + String.fromCharCode(39) + ", " + String.fromCharCode(39) + change.path + String.fromCharCode(39) + ")\\">‚úì Keep</button>"; html += "<button class=\\"copilot-action-btn copilot-undo-btn\\" onclick=\\"undoFileChange(" + String.fromCharCode(39) + changeId + String.fromCharCode(39) + ", " + String.fromCharCode(39) + change.path + String.fromCharCode(39) + ", " + String.fromCharCode(39) + change.type + String.fromCharCode(39) + ")\\">‚úó Undo</button>"; html += "</div>"; html += "</div>"; if (change.details && change.details.length > 0) { html += "<div class=\\"copilot-change-details\\">"; change.details.forEach(function(detail) { html += "<div class=\\"copilot-detail-line\\">‚Ä¢ " + escapeHtml(detail) + "</div>"; }); html += "</div>"; } html += "</div>"; }); html += "</div>"; if (commands && commands.length > 0) { html += "<div class=\\"copilot-commands-section\\">"; html += "<div class=\\"copilot-section-title\\">‚ö° Commands executed</div>"; commands.forEach(function(cmd) { var cmdText = typeof cmd === "string" ? cmd : cmd.command; html += "<div class=\\"copilot-command-item\\">"; html += "<code class=\\"copilot-command-text\\">$ " + escapeHtml(cmdText) + "</code>"; if (cmd.output) { html += "<div class=\\"copilot-command-output\\">" + escapeHtml(cmd.output.substring(0, 200)) + (cmd.output.length > 200 ? "..." : "") + "</div>"; } if (cmd.exit_code !== undefined && cmd.exit_code !== 0) { html += "<div class=\\"copilot-command-error\\">Exit code: " + cmd.exit_code + "</div>"; } html += "</div>"; }); html += "</div>"; } html += "</div>"; return html; }
function toggleFileChanges(cardId) { try { var card = document.getElementById(cardId); if (card) { card.classList.toggle("collapsed"); } } catch(e) { console.error("[toggleFileChanges error]", e); } }
function openFileAndHighlight(filePath) { try { console.log("[Opening file with highlight]:", filePath); safePostMessage({ type: "openFile", filePath: filePath, highlight: true }); } catch(e) { console.error("[openFileAndHighlight error]", e); } }
function keepFileChange(changeId, filePath) { try { console.log("[Keeping change]:", filePath); var changeEl = document.getElementById(changeId); if (changeEl) { changeEl.classList.add("kept"); var keepBtn = changeEl.querySelector(".copilot-keep-btn"); var undoBtn = changeEl.querySelector(".copilot-undo-btn"); if (keepBtn) { keepBtn.textContent = "‚úì Kept"; keepBtn.disabled = true; } if (undoBtn) { undoBtn.style.display = "none"; } setTimeout(function() { changeEl.style.opacity = "0.6"; changeEl.style.pointerEvents = "none"; }, 300); } safePostMessage({ type: "keepFileChange", filePath: filePath }); } catch(e) { console.error("[keepFileChange error]", e); } }
function undoFileChange(changeId, filePath, changeType) { try { console.log("[Undoing change]:", filePath, changeType); var changeEl = document.getElementById(changeId); if (changeEl) { changeEl.classList.add("undoing"); setTimeout(function() { changeEl.style.transform = "translateX(-100%)"; changeEl.style.opacity = "0"; setTimeout(function() { changeEl.remove(); }, 300); }, 100); } safePostMessage({ type: "undoFileChange", filePath: filePath, changeType: changeType }); } catch(e) { console.error("[undoFileChange error]", e); } }
function copyCodeBlock(codeId) { try { var codeBlock = document.getElementById(codeId); if (codeBlock) { var text = codeBlock.textContent; navigator.clipboard.writeText(text).then(function() { console.log("Code copied to clipboard"); var btn = event.target; var originalText = btn.textContent; btn.textContent = "‚úÖ Copied!"; setTimeout(function() { btn.textContent = originalText; }, 2000); }); } } catch(e) { console.error("[copyCodeBlock error]", e); } }
function openFileLink(filePath) { try { console.log("[Opening file]:", filePath); safePostMessage({ type: "openFile", filePath: filePath }); } catch(e) { console.error("[openFileLink error]", e); } }

        // Claude Code-style Approval Functions
function showApprovalCard(changes) { try { console.log("[showApprovalCard] Showing approval for", changes.length, "changes"); var approvalHtml = "<div class=\\"approval-card\\" id=\\"approvalCard\\">"; approvalHtml += "<div class=\\"approval-header\\"><span class=\\"approval-icon\\">üîç</span><div><div class=\\"approval-title\\">Review Changes</div><div class=\\"approval-subtitle\\">" + changes.length + " change(s) pending approval</div></div></div>"; approvalHtml += "<div class=\\"approval-changes-preview\\">"; changes.forEach(function(change) { var icon = change.type === "create" ? "+" : (change.type === "modify" ? "~" : "√ó"); approvalHtml += "<div class=\\"approval-change-item\\"><span class=\\"approval-change-icon\\">" + icon + "</span><span>" + escapeHtml(change.path) + "</span></div>"; }); approvalHtml += "</div>"; approvalHtml += "<div class=\\"approval-actions\\">"; approvalHtml += "<button class=\\"approval-btn approval-btn-preview\\" onclick=\\"previewChanges()\\">Preview All</button>"; approvalHtml += "<button class=\\"approval-btn approval-btn-reject\\" onclick=\\"rejectChanges()\\">Reject</button>"; approvalHtml += "<button class=\\"approval-btn approval-btn-accept\\" onclick=\\"acceptChanges()\\">Accept All</button>"; approvalHtml += "</div></div>"; var messageDiv = document.createElement("div"); messageDiv.className = "message message-system"; messageDiv.innerHTML = approvalHtml; messagesContainer.appendChild(messageDiv); messagesContainer.scrollTop = messagesContainer.scrollHeight; } catch(e) { console.error("[showApprovalCard error]", e); } }
function previewChanges() { try { console.log("[previewChanges] Requesting preview"); safePostMessage({ type: "previewChanges" }); } catch(e) { console.error("[previewChanges error]", e); } }
function acceptChanges() { try { console.log("[acceptChanges] Accepting all changes"); safePostMessage({ type: "acceptChanges" }); var card = document.getElementById("approvalCard"); if (card) { card.style.opacity = "0.5"; card.innerHTML = "<div class=\\"approval-header\\"><span class=\\"approval-icon\\">‚úÖ</span><div><div class=\\"approval-title\\">Changes Accepted</div><div class=\\"approval-subtitle\\">Applying changes...</div></div></div>"; setTimeout(function() { if (card) card.remove(); }, 2000); } } catch(e) { console.error("[acceptChanges error]", e); } }
function rejectChanges() { try { console.log("[rejectChanges] Rejecting all changes"); safePostMessage({ type: "rejectChanges" }); var card = document.getElementById("approvalCard"); if (card) { card.style.opacity = "0.5"; card.innerHTML = "<div class=\\"approval-header\\"><span class=\\"approval-icon\\">‚ùå</span><div><div class=\\"approval-title\\">Changes Rejected</div><div class=\\"approval-subtitle\\">Discarding changes...</div></div></div>"; setTimeout(function() { if (card) card.remove(); }, 2000); } } catch(e) { console.error("[rejectChanges error]", e); } }

function renderTodos(todos, stats, context, relatedFiles) {
    try {
        console.log("[renderTodos] Called with todos:", todos ? todos.length : 0);
        if (!todos || todos.length === 0) {
            console.log("[renderTodos] No todos to render");
            return;
        }
        if (!messagesContainer) {
            console.error("[renderTodos] messagesContainer not found!");
            return;
        }

        const completedCount = stats ? stats.completed : 0;
        const totalCount = stats ? stats.total : todos.length;
        const activeTodos = todos.filter(function(t) { return t.status !== "completed"; });
        console.log("[renderTodos] Active todos:", activeTodos.length);

        if (activeTodos.length === 0) {
            console.log("[renderTodos] No active todos");
            return;
        }

        // Remove existing todo cards
        var existingTodoCards = messagesContainer.querySelectorAll(".message.message-system .inline-todo-card");
        if (existingTodoCards.length > 0) {
            console.log("[renderTodos] Removing", existingTodoCards.length, "existing todo cards");
            existingTodoCards.forEach(function(card) {
                var messageEl = card.closest(".message.message-system");
                if (messageEl) messageEl.remove();
            });
        }

        // Sort todos by order field for sequential execution
        const sortedTodos = activeTodos.slice().sort(function(a, b) {
            const orderA = a.order !== undefined ? a.order : 999;
            const orderB = b.order !== undefined ? b.order : 999;
            return orderA - orderB;
        });

        // Find the current active todo (first non-completed)
        let activeIndex = -1;
        for (let i = 0; i < sortedTodos.length; i++) {
            if (sortedTodos[i].status !== "completed") {
                activeIndex = i;
                break;
            }
        }

        const todoHtml = "<div class=\\"inline-todo-card\\">" +
            "<div class=\\"inline-todo-header\\">üìã Tasks (" + sortedTodos.length + " total, " + completedCount + " completed)</div>" +
            sortedTodos.map(function(todo, index) {
                const isActive = (index === activeIndex);
                const isCompleted = todo.status === "completed";
                const isPending = !isActive && !isCompleted;

                let status, icon, statusClass;
                if (isCompleted) {
                    status = "completed";
                    icon = "‚úÖ";
                    statusClass = "completed";
                } else if (isActive) {
                    status = "in_progress";
                    icon = "‚è≥";
                    statusClass = "in_progress active";
                } else {
                    status = "pending";
                    icon = "‚¨ú";
                    statusClass = "pending";
                }

                const todoId = "todo_" + index;
                const orderBadge = (todo.order !== undefined) ? "<span class=\\"todo-order\\">#" + (todo.order + 1) + "</span>" : "";

                console.log("[renderTodos] Creating todo", index, "- order:", todo.order, "status:", status, "isActive:", isActive);

                var html = "<div class=\\"inline-todo-item " + statusClass + "\\" data-todo-id=\\"" + todoId + "\\" data-todo-text=\\"" + escapeHtml(todo.text) + "\\" data-order=\\"" + (todo.order || 0) + "\\">";
                html += "<div class=\\"todo-item-content\\">";
                html += "<span class=\\"todo-icon\\">" + icon + "</span>";
                html += "<span class=\\"todo-text\\">" + escapeHtml(todo.text) + "</span>";
                html += orderBadge;
                html += "</div>";
                if (isActive) html += "<div class=\\"todo-status-label\\">IN PROGRESS</div>";
                if (isPending) html += "<div class=\\"todo-status-label pending-label\\">PENDING</div>";
                html += "</div>";
                return html;
            }).join("") +
            "</div>";

        const messageDiv = document.createElement("div");
        messageDiv.className = "message message-system";
        messageDiv.innerHTML = todoHtml;
        console.log("[renderTodos] Adding todo card to messagesContainer");
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        console.log("[renderTodos] Todo card added successfully with sequential execution");
    } catch(e) {
        console.error("[renderTodos error]", e);
    }
}
function toggleTodoItem(todoId) { try { safePostMessage({ type: "toggleTodo", todoId: todoId }); } catch(e) { console.error("[toggleTodo error]", e); } }
function updateTodoStatus(todoId, status) { try { console.log("[updateTodoStatus] Updating todo:", todoId, "to status:", status); const todoCards = document.querySelectorAll(".inline-todo-card"); todoCards.forEach(function(card) { const items = card.querySelectorAll(".inline-todo-item"); items.forEach(function(item) { const text = item.textContent.trim(); if (text.includes(todoId) || item.dataset.todoId === todoId) { item.className = "inline-todo-item " + status; const icon = status === "in_progress" ? "‚è≥" : status === "completed" ? "‚úÖ" : "‚¨ú"; const textContent = item.textContent.replace(/^[‚¨ú‚è≥‚úÖ]\s*/, ""); item.innerHTML = icon + " " + escapeHtml(textContent); console.log("[updateTodoStatus] Updated todo item:", textContent, "to", status); } }); }); } catch(e) { console.error("[updateTodoStatus error]", e); } }
function getFileIcon(filePath) { if (!filePath) return "üìÑ"; const pathStr = typeof filePath === "string" ? filePath : (filePath.path || String(filePath)); const ext = pathStr.split(".").pop().toLowerCase(); const iconMap = { "js": "üìú", "ts": "üìò", "jsx": "‚öõÔ∏è", "tsx": "‚öõÔ∏è", "py": "üêç", "java": "‚òï", "cpp": "‚öôÔ∏è", "c": "‚öôÔ∏è", "h": "üìã", "css": "üé®", "html": "üåê", "json": "üìã", "md": "üìù", "txt": "üìÑ", "yml": "‚öôÔ∏è", "yaml": "‚öôÔ∏è", "xml": "üìã", "svg": "üñºÔ∏è", "png": "üñºÔ∏è", "jpg": "üñºÔ∏è", "jpeg": "üñºÔ∏è", "gif": "üñºÔ∏è", "sh": "üîß", "bash": "üîß", "go": "üî∑", "rs": "ü¶Ä", "php": "üêò", "rb": "üíé", "swift": "ü¶Ö", "kt": "üî∂" }; return iconMap[ext] || "üìÑ"; }
function escapeHtml(text) { const div = document.createElement("div"); div.textContent = text; return div.innerHTML; }
</script>
